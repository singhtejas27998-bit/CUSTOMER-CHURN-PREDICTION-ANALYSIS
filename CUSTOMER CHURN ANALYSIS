"""
Customer Churn Prediction ML System
Requirements:
    pip install pandas numpy scikit-learn joblib xgboost
"""

import pandas as pd
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.pipeline import Pipeline
from sklearn.metrics import (
    classification_report, confusion_matrix, roc_auc_score
)
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
import joblib


def load_data(csv_path, target_col="churn"):
    df = pd.read_csv(csv_path)

    if target_col not in df.columns:
        raise ValueError(f"Target column '{target_col}' not found")

    X = df.drop(columns=[target_col])
    y = df[target_col]
    return X, y


def build_pipeline(X, model_type="xgboost"):
    numeric_features = X.select_dtypes(include=[np.number]).columns.tolist()
    categorical_features = X.select_dtypes(exclude=[np.number]).columns.tolist()

    numeric_transformer = StandardScaler()
    categorical_transformer = OneHotEncoder(handle_unknown="ignore")

    preprocessor = ColumnTransformer(
        transformers=[
            ("num", numeric_transformer, numeric_features),
            ("cat", categorical_transformer, categorical_features),
        ]
    )

    if model_type == "xgboost":
        model = XGBClassifier(
            n_estimators=300,
            learning_rate=0.05,
            max_depth=6,
            subsample=0.8,
            colsample_bytree=0.8,
            eval_metric="logloss",
            random_state=42,
            scale_pos_weight=1.5  # to balance churn imbalance
        )
    else:
        model = RandomForestClassifier(
            n_estimators=300,
            class_weight="balanced",
            random_state=42,
            n_jobs=-1
        )

    clf = Pipeline(
        steps=[("preprocessor", preprocessor),
               ("classifier", model)]
    )
    return clf


def train_model(csv_path, target_col="churn", test_size=0.2, model_path="churn_model.joblib"):
    X, y = load_data(csv_path, target_col)

    print("\nDataset Info\n------------------")
    print("Shape:", X.shape)
    print("Churn distribution:\n", y.value_counts(normalize=True))

    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=test_size, stratify=y, random_state=42
    )

    clf = build_pipeline(X, model_type="xgboost")

    print("\nTraining model...")
    clf.fit(X_train, y_train)

    print("\nEvaluating model...")
    y_pred = clf.predict(X_test)

    # Probability score for ROC
    y_prob = clf.predict_proba(X_test)[:, 1]
    roc_auc = roc_auc_score(y_test, y_prob)

    print("\nROC-AUC:", roc_auc)
    print("\nConfusion Matrix:\n", confusion_matrix(y_test, y_pred))
    print("\nClassification Report:\n", classification_report(y_test, y_pred, digits=4))

    joblib.dump(clf, model_path)
    print(f"\nModel saved to: {model_path}")

    return clf


def load_trained_model(model_path="churn_model.joblib"):
    return joblib.load(model_path)


def predict_single_customer(model, data_dict: dict):
    # data_dict example:
    # {
    #   "tenure": 5,
    #   "monthly_charges": 75,
    #   "contract": "Month-to-month",
    #   "payment_method": "Credit card",
    #   ...
    # }

    X_new = pd.DataFrame([data_dict])
    pred = model.predict(X_new)[0]
    prob = model.predict_proba(X_new)[0, 1]

    return int(pred), float(prob)


if __name__ == "__main__":
    csv_path = "customer_churn.csv"  # Replace with your dataset
    target = "churn"

    model = train_model(csv_path, target_col=target)

    # Example prediction
    sample_customer = {
        "tenure": 3,
        "monthly_charges": 85.5,
        "contract": "Month-to-month",
        "payment_method": "Credit card",
        "internet_service": "Fiber optic",
        "tech_support": "No",
    }

    label, probability = predict_single_customer(model, sample_customer)
    print("\nðŸ§¾ Prediction Example")
    print("Will churn (0=no, 1=yes):", label)
    print("Churn probability:", probability)
